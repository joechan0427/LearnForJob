# ACID (事务的四大特性)
- atomicity(原子性): 事务, 不可分割的最小单元. 回滚可以用 undo log 实现
- consistency(一致性): 事务前后保持正确的状态, (如果出现转账后 A 的账户余额小于 0)
- isolation(隔离性): 在事务提交前, 对于其他事务是不可见的
- durability(持久性): 一旦提交, 将永远保存

![](https://camo.githubusercontent.com/d688683e3f6fb14d059412247e4f427a7cd1aa7686417bc552e061628f24dd84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67)

# 并发一致性问题
## 1. 丢失修改
一个事务的更新操作被另一个事务的更新操作替换
![](https://camo.githubusercontent.com/43e0bcae7603de0e236f6e4c73ac4343c279d00a2dc8f144cadf368caabd565a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67)
## 2. 读脏数据
读到其他事务未提交的数据, 此时若该事务回滚, 则读到的数据不正确
![](https://camo.githubusercontent.com/153121db732e2d471cd447a0bead75acd302d68962b36ba391d607141a701654/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67)
## 3. 不可重复读
在事务执行过程中, 两次读取的数据不一致, 这是因为, 在此期间读到其他事务提交前后的数据
![](https://camo.githubusercontent.com/718d52fc7785b8c4c6878b8218adcad1a8c66b8a05fc5a581226e7c9950db004/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67)
## 4. 幻读
与不可重复读类似, 不过是读到的范围不一致
![](https://camo.githubusercontent.com/5f8d71358b5743f013a80fc9d20563d2ac6a21a514c0d7ff9a4b1db6388a6bd7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67)

# 封锁
## 封锁粒度
- 表级锁
- 行级锁

锁粒度越大, 并发越低
锁粒度越小, 频繁加锁, 释放锁的系统开销越大
应该在 系统开销 和 并发控制 之间做平衡

## 封锁类型
### 1. 读写锁
- 互斥锁 (Exclusive): 写锁, X 锁
- 共享锁 (Shared): 读锁, S 锁

锁的兼容关系
![](https://camo.githubusercontent.com/c04b0f9003db3c86021fd3d61d95f44342bf87c5e1c1ca74654080dc48b5205b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231333532333737372e706e67)

### 2. 意向锁(都是表锁)
原因 : 在给一张表上写锁时, 需要对每一行都检查是否上锁, 非常耗时
规定 : 
1. 在事务获得表或行的 S 锁之前, 必须先获得 IS 锁 IX 锁
2. 在获得 X 锁之前, 必须先获得 IX 锁

各种锁的兼容性: 
![](https://camo.githubusercontent.com/69fa31ccb1308138411ff97e3b1021bdb84bfbbf786d722085461995027c31bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231343434323638372e706e67)

解释: 
1. 意向锁都是互相兼容, 因为并未真正加锁
2. 这里的兼容表示表级别, 如果有两个事务对两个数据行分别加锁, 那么可以完成, 因为 IX/IS 彼此兼容

# 三级封锁协议
## 1. 一级封锁
对一个数据修改, 必须获得 X 锁, 可以==解决修改丢失==
![](https://camo.githubusercontent.com/bf114f3f2deb51dcc5c4add4c0533670dcc3da6e91bb33e26abb7021c8b4fdcd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303434303435312e706e67)

## 2. 二级封锁
对一个数据读取, 必须获得 S 锁, 读取后立即释放, 可以解决 ==脏读==
![](https://camo.githubusercontent.com/562fb5687b3a68df44c9ca50d85626d31e5f429ba8cb328f0bc26ce63126f46e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303833313834332e706e67)

## 3. 三级封锁
对一个数据读取, 必须获得 S 锁, 到提交才释放, 可以解决 ==不可重复读==
![](https://camo.githubusercontent.com/67e5859aaf5cb0ce2aa60a44257636af20f762e205b107a519663e6811f83abc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313331333831392e706e67)

# 隔离级别

1. 未提交读 (Read Uncommitted)
2. 提交读 (Read committed)
3. 可重复 (Repeatable Read)
4. 可串行化 (Serializable)

![](https://camo.githubusercontent.com/1632a88a3a4fa7954026cb939edf2f8a30bb5d60a1bce4921c7e0d0e4d245739/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67)

# MVCC (多版本并发控制)
innoDB 引擎实现隔离级别的一种具体方式, 实现提交读和可重复读
未提交读只需读取最新状态, 无需 MVCC.
而串行化需要对所有读取的行加锁

## 基本思想
在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

## 版本号
- 系统版本号 SYS_ID : 递增, 每开启一个新事务, 系统版本号就会递增
- 事务版本号 TRX_ID : 系统开始时的系统版本号

## Undo日志
MVCC 的多版本是指多个快照, 快照存储在 Undo 日志中
```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 START TRANSACTION 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

![](https://camo.githubusercontent.com/648b989516b41055bbd1f39ee4b61a6b0a00e0d0114632dceb1c6b91ec39dca6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67)

## ReadViev
该数据结构里包含了所有未提交的事务, 并维护该列表里的最小和最大 TRX_ID
![](https://camo.githubusercontent.com/1fe81e9af90e3b9256a607920773eab0c685bda03fbb947a2c1a4d26ff55c21e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383137313434353637342e706e67)

当事务在进行 select 操作时, 会比较 TRX_ID_MIN, TRX_ID_MAX 和该数据行的 TRX_ID 的关系
1. 当 TRX_ID < TRX_ID_MIN, 表示该数据行更新于所有未提交事务之前, 可以读取
2. 当 TRX_ID > TRX_ID_MAX, 表示该数据行更新于所有未提交事务之后, 不可以读取
3. 当 TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX
    1. 提交读, 当该 TRX_ID 在 ReadView 列表中时, 不可使用. 若不在时, 说明已提交, 可用
    2. 可重复读, 都不可用

如果不满足, 需要在 Undo 日志中寻找上一个 TRX_ID, 再次重复上述操作

## 快照读与当前读
1. 快照读
MVCC 的 select 操作是快照中的数据, 不需要加锁
2. 当前读
可以选择加锁
```sql
select * from t in share mode;
select for update
```

# Next-key locks
MVCC 不能解决幻影读, nkl 为了解决此问题诞生的
## record lock
锁定索引, 而非记录, 如, 11, 14
## gap lock
锁定两个索引之间的空隙, 如 (11, 14)
## next-key locks
上述两者的结合, 是一个前开后闭的区间, (]
如果一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
```java
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

# 三大范式
## 第一范式
属性不可再分
| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 |
| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |
## 第二范式
非主属性完全函数依赖于键码
如上表, 其中grade完全函数依赖于键码 (Sno, Cname), 因此可以拆分
| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 |
| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |
## 第三范式
非主属性不传递函数依赖于键码
如上表, 其中院长传递依赖于 sno, 因此可以拆分


# 索引
## 为什么使用索引
1. 加快检索速度
2. 索引自带排序
3. 将随机 I/O 转换为顺序 I/O 

## MySQL的两种索引
### 哈希索引
根据 Hash 函数定位到数据所在的位置，这是 B+树所不能比的。
==Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点。==
InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
### B+树索引
#### MyISAM
非聚簇索引, 索引存储的 data 是指针
#### InnoDB
索引就是数据文件本身, 树的叶节点 data 存储了完整的数据记录, 索引的 key 是数据的主键(聚集索引). 
其余的索引都作为辅助索引, 辅助索引的 data 域存储的是主键的值. 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂
#### B+树的基本存储结构
MySQL 的基本存储结构是页(==16KB==)
![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/28559421.jpg)
![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/82053134.jpg)
![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/5373082.jpg)
![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/89338047.jpg)
#### 和 B树 的区别
1. B树的所有节点即存储索引, 又存储 data, 而B+树只在叶子节点存储 data
2. B+ 树的叶子节点存在一条指向下一个节点的引用链, 这样在遍历时能够加快速度. 而B树的叶子节点是独立的
3. 由1, 当检索一个值时, B树可能还没到叶子节点就结束, 而B+树任何检索都是根节点到叶子节点
#### 与红黑树相比
1. 都是自平衡树
2. 红黑树的出度为2, 意味着红黑树的树深度更大, 也就是要查找到一个节点需要更多的 I/O 操作
3. B+树的一个节点大小设置为磁盘一个页的大小, 这样一次 I/O 可以读入一整个节点

## 二级索引(辅助索引)
==唯一索引, 普通索引, 前缀索引都是二级索引==
1. 唯一索引 (Unique key): 唯一索引是一种约束, 唯一索引的属性不能出现重复的值, 但可以为 null, 允许创建多个唯一索引. 目的在于数据的唯一性, 而非加快检索速度
2. 普通索引 (index): 允许数据重复和为 null
3. 前缀索引 (prefix): 前缀索引只适用于字符串类型的数据, 是对==文本的前几个字符==建立索引, 因此数据量较小
4. 全文索引 (full Text): 为了检索大文本数据中的关键词信息

## 覆盖索引
一个索引(对于二级索引而言)包含了所有需要查询的字段. 此时不需要回表(二次查询), 可以加快检索速度

## explain 语句
重要字段
1. type 
    - const(主键,最多仅匹配一条),
    - eq_ref(多表join, 对于前面的每一行, 在当前表中只能找到一行, 使用的是主键或唯一索引)
    - ref(多表join, 对于前面的每一行, 在当前能找到多行, 可用于 = 或 <=> (与null值比较, 相当于 is null) )
    - range(范围查找, 常见于 <=, between, like, in)
    - index(索引全部扫描, 如果使用了覆盖索引, 在extra中会显示 Using index)
    - all(全表扫描
2. rows
**估算**需要扫描的条数, 越小越好
3. extra
    - using filesort, 表示不能通过索引达到排序, 需额外排序, 建议优化
    - using index, 表示覆盖索引
    - using temporary, 使用临时表, 一般出现于排序, 分组, 多表join的情况
## 索引创建的注意事项
1. 最左前缀
当联合索引为(colA, colB, colC)时, 只有按照索引创建的顺序作为查询条件, 才能使用索引. 换句话说, 如果查询条件仅包含 colB 或 colC时, 不能使用索引
2. 避免冗余索引
即命中 A索引, 必定能命中 B索引(一个(name)的索引, 一个(name, age)的索引), 此时应考虑删除其中一个
3. 对于字符串类型的字段, 考虑使用前缀索引, 能占用少一点的存储空间
4. 索引列不能表达式的一部分, 也不能是函数的参数, 否则无法使用索引
如:
    ```sql
    where id+1 = 2
    ```
5. 将选择性强的字段放在联合索引的前面
选择性: `count(distinct col)/count(*)`

# MySQL 执行一条 sql 语句的过程
## 查询语句
```sql
select * from student  A where A.age='18' and A.name='张三';
```
- 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在mysql8.0版本以前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 通过分析器进行词法分析，提取sql语句的关键元素，比如提取上面这个语句是查询select，提取需要查询的表名为tb_student,需要查询所有的列，查询条件是这个表的id='1'。然后判断这个sql语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。
- 接下来就是优化器进行确定执行方案，上面的sql语句，可以有两种执行方案： a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18。 b.先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生。 那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。
- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。
## 更新语句
```sql
update student A set A.age='19' where A.name='张三';
```
- 先查询到张三这一条数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的语句，把 age 改为19，然后调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录binlog，然后调用引擎接口，提交redo log 为提交状态。