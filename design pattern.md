# 设计模式
## 六大设计原则
1. **单一职责**
每个类应该只完成一项职责, 如果有多项任务, 应该由多个类共同实现, 而不是一个臃肿的类实现所有功能
代表: 责任链
好处: 解耦, 当需要去除或添加某项功能时方便
2. **开闭原则**
对修改关闭, 对扩展开放
代表: 继承与重写
3. **里氏替换**
父类可以由子类实现替换, 其实也是面向接口编程
代表: List 可以由 ArrayList 或 LinkedList 实现
好处: 解耦
4. **依赖倒转**
细节依赖于抽象, 而不是抽象依赖于细节
比如: 我们先写接口(接口应该有什么方法), 再去写实现类. 
再具体地说: 比如我们要画个图, 我们应该写个接口, 里面有个 draw 方法, 然后再写三角形的类, 实现这个接口, 然后里面再调用画线的方法, 画线里面调用画点的方法. (这样与我们平时作画不一样)
5. **接口隔离**
  使用多个专门的接口, 客户端不应该被迫依赖于它不使用的方法
  要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
  与单一职责区别:
    1. 单一职责强调类的职责, 而接口隔离强调接口的职责的隔离
6. **最少知识原则**
不需要知道其他类内部是怎么实现

# 创建型
## 单例模式

## 工厂模式
### 简单工厂模式
客户端(调用端)不用去关心对象的创造过程, 工厂把这一细节给屏蔽了, 使得客户端与对象解耦

如: 定义一个餐馆, 我们只关心点的菜, 不关心制作过程

### 工厂方法模式
定义一个用于创建对象的接口, 让子类决定实例化具体的类, 工厂方法使一个类的实例化延迟到子类

如: 由于单一职责, 每个餐馆的制作过程可能不同, 比如中式餐厅和西式餐厅. 因此我们定义一个提供食物的接口, 所有具体餐厅都实现提供食物的方法即可

### 抽象工厂方法
为一组相关或相互依赖的对象提供一个接口, 并且无需指定具体类

### 工厂模式例子
1. 简单工厂好比一个具体的餐馆, 客户需要指定具体餐馆的具体菜, 但不需要客户知道提供食物的细节
2. 工厂方法模式好比一个平台, 客户只需要调用统一的方法即可
3. 抽象工厂好比再抽象, 比如客户需要一台台式机, 我们可以使用多个简单工厂去提供 cpu, 主板等, 再由客户组装, 但可能会有兼容性问题, 此时可以提供一个统一的电脑类, 帮我们解决兼容的问题


# 行为型
## 责任链模式

## 迭代器模式

# 结构型
## 适配器模式
如 Arrays.asList()

## 代理模式