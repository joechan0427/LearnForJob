


# 网络层
## 常见应用端口及协议
| 应用程序 | FTP | TFTP | TELNET | SMTP	| DNS | HTTP | SSH | MYSQL |
| - | - | - | - | - | - | - | - | - |
| 熟知端口 | 21,20 | 69 | 23 | 25 | 53	| 80 | 22 | 3306
|传输层协议	|TCP|	UDP|	TCP|	TCP|	UDP|	TCP|	TCP|	TCP
## TCP (transmission control protocol)
> TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。

### TCP 报文
![](https://camo.githubusercontent.com/690200ac72bf19ad2e859901f61d7e4d3a21c83608d9dd62a1146eca359cf655/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67)

- 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；
- 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，==一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；==
- 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，==B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；==
- 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
保留，占6位，保留今后使用，但目前应都位0；
- 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
- 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
- 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
- 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
- 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
- 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
- 检验和，占2字节，校验首部和数据这两部分；
- 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；
- 选项，长度可变，定义一些其他的可选的参数。

### TCP连接的建立（三次握手）
![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png)

1. 客户端发送连接请求报文, 其中报文首部中的 SYN 标志设置为1, 序号seq设为 x, 进入 SYN_SENT 状态 (TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。)
2. 服务端收到这个请求报文, 同意建立请求, 返回确认报文, 其中首部 ACK 标志设置为 1, 确认序号 ack = x + 1, 同时, 这个报文也是一个请求连接报文, 因此 SYN = 1, 序号 seq = y, 进入 SYN_RCVD(recieved) 状态 (这个报文也不能携带数据，但是同样要消耗一个序号。)
3. 客户端收到该报文, 返回一个确认报文, ACK = 1, ack = y+1, seq = x + 1 (TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号)

#### 为什么要进行最后一次握手
1. 防止建立重复连接
如果是两次连接, 那么第一次握手如果超时重发(==客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了==), 那么服务端将会首先建立起一次连接, 等到客户端的第一个请求报文到达后, 又建立一次连接
但是三次握手, 服务端没有收到第二次连接的第三次握手, 则不会开启连接
2. 从双方确立可靠通信的角度
第一次握手, 客户端什么都不能确定, 服务端确定自己的接收, 对方的发送功能正常
第二次握手, 客户端确定自己的发送接收, 对方的发送接收正常, 而服务端确定自己的接收, 对方的发送正常
第三次握手, 双方确定彼此的发送接收正常

### TCP连接的释放 (四次挥手)

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png)

1. 客户端发送连接释放报文, 其中首部的 FIN 标志设置为 1 , 序号 seq = u (前面传送过去的最后一个字节序号加1), 此时进入 FIN-WAIT-1(终止等待2状态) 状态. 此时客户端不能再传送数据 ==TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。==
2. 服务端收到连接释放报文, 返回确认报文, ACK=1, 确认序号 ack = u+1, 带上自己的序号 seq = v, 此时服务端仍能发送数据, 持续 CLOSE-WAIT(半关闭状态) 时间
3. 客户端接收到服务器的确认后, 进入 FIN-WAIT-2 (终止等待2状态) 
4. 服务端没有数据发送了, 发送连接释放报文, 报文 FIN=1, ack = u+1, 序号 seq = w (传送的最后数据序号+1), 服务端进入 LAST-ACK 状态.
5. 客户端接收到服务端的连接释放报文, 发送确认报文, 其中 ACK=1, ack=w+1, seq=u+1, 此时客户端进入 TIME-WAIT(时间等待) 阶段, 此时客户端 TCP 还没有释放, 需要等待 2*MSL(maximum section lifetime, 最长报文寿命), 才进入 CLOSE 状态
6. 服务端一接收到客户端的确认报文, 立即进入 CLOSE 状态

#### 为什么需要等待 2*MSL
1. 因为客户端最后一个报文可能丢失, 如果丢失, 则服务端不能进入关闭状态, 会一直重发一个请求确认的报文, 如果客户端在这个 TIME-WAIT 状态再次收到服务端的请求确认的报文, 则会再发送一次最后确认报文
2. 为了让这次 TCP 连接的所有报文消失在网络中, 不影响下次连接

#### 为什么握手是三次, 挥手是四次
因为握手时, 第二次握手是请求建立连接和确认请求放在一个报文里
而挥手时, 服务端接收到客户端的连接释放请求后, 可以继续发送数据, 因此需要分开确认报文和连接释放报文

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### TCP如何实现可靠传输
1. 超时重传
2. arq (Automatic Repeat reQuest)协议
3. 数据分包, 编号
4. 校验和
存在于 tcp 报文首部, 保存着首部和数据的检验和
5. 拥塞控制
6. 流量控制

#### ARQ 协议
自动重传请求（Automatic Repeat-reQuest，ARQ）是==OSI模型中数据链路层和传输层==的错误纠正协议之一
##### 停止等待 ARQ
每发完一个分组即停止等待回复
##### 连续ARQ
维护一个发送窗口, 处于发送窗口中的分组可以连续发送, 而接收方只需要对最后一个有序分组确认
缺点: 可能需要回退多个, 如中间某一个丢失, 将从该包到最后一个包再发送一次
##### 确认丢失
A 向 B 发送 M1 消息, B 收到后发送的确认消息丢失, 此时 A 再次发送 M1 消息, 则 B 收到后, 1) 丢弃该消息 2) 再次向 A 发送确认消息
##### 确认迟到
A 向 B 发送 M1 消息, B 收到后发送的确认消息丢失, 此时 A 再次发送 M1 消息, 则 B 收到后, 再次发送确认消息, A, B 继续传送消息, 一段时间后, A 收到 B 第一次发送的 M1 确认消息, 直接丢弃

#### 流量控制
tcp 接收双方都维护一个滑动窗口, 接收方通过 tcp 首部的窗口字段来告诉发送方自己的窗口大小, 发送方根据该值和其他信息来设置自己的窗口大小
比如, 接收方可以将该值设置为 0, 则发送方不能发送数据
#### 拥塞控制
如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。
==tcp 主要通过四个算法实现拥塞控制: 慢开始, 拥塞避免, 快恢复, 快重传==
发送方需要维护一个**拥塞窗口 (cwnd)** 的状态变量, 与发送窗口的区别: cwnd 只是一个状态变量, 实际能发送多少数据还是由发送窗口控制, 事实上, 发送窗口约等于 cwnd 和接收窗口的较小值

![](https://camo.githubusercontent.com/96b543c35dfc6a024897cea0354427605b9d238d7af0e8c5821c7ab0c26c2f27/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67)

1. **慢开始和拥塞避免**
最开始执行慢开始, 即 cwnd = 1, 此后每次收到确认报文将 cwnd 翻倍, 2, 4, ...
当达到设定的 ssthrech, 进入拥塞避免, 即每轮将 cwnd + 1
而如果遇到超时重发, 则将 ssthrech = cwnd/2, cwnd = 1
2. **快重传和快恢复**
如果某次连续收到三个同样的确认报文, 则可确认下一个报文丢失, 此时立即执行快重传, 传输下一个报文.
同时, 由于只是丢失个别报文, 并非网络拥塞, 所以执行快恢复, 将 ssthrech = cwnd/2, cwnd = ssthrech, 即马上进入拥塞避免

# 应用层
## HTTP
![](https://img2018.cnblogs.com/blog/885859/201907/885859-20190724173242717-440362909.png)

### HTTP方法
1. GET
2. HEAD: 与GET类似, 但是没有响应体, 主要用于确认 URL 的有效性以及资源更新的日期时间等。
3. POST
4. PUT
5. DELETE

### HTTP 响应码
100: continue. 继续, 客户端应该继续其请求
200: OK
206: Partial Content. 部分内容, HTTP1.1 加入
301: moved permanently. 永久重定向
302: found. 临时重定向
304: not modified. 内容未修改
400: bad request. 客户端语法错误, 服务端不能理解
401: unauthorized. 未授权
403: forbidden. 请求被拒绝
404: not found
500: internal server error. 服务端内部错误
502: bad gateway. 网关或代理执行请求时, 收到服务端无效响应
503: server unavailable. 服务端正在维护