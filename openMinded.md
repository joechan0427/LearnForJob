# 奇怪的排序算法
[排序](https://zhuanlan.zhihu.com/p/53464092)

# bitmap

# rand5 实现 rand7
当实现比 randn 更小的数时, 可以直接丢弃大于 x 的值
```java
Rand5 rand5 = new Rand5();
public int rand3(Rand5 rand5) {
    int ret = Math.MAX_VALUE;
    while (ret > 3) {
        ret = rand5.nextInt();
    }
    return ret;
}
```

因此, 基于这样的思想, 我们可以构造一个大于目标数字的区间, 计算公式
```math
n * (randN - 1) + randN
```
如 rand5, rand5-1 = 0, 1, 2, 3, 4, 再乘 5, 则得到 0, 5, 10, 15, 20 的概率相等, 再加上 rand5, 则每个的概率为 1/5 * 1/5

```java
Rand5 rand5 = new Rand5();
public int rand7(Rand5 rand5) {
    int ret = Math.MAX_VALUE;
    // 能减少运行时间
    while (ret > 21) {
        ret = rand5.nextInt();
    }
    return ret % 7 + 1;
}
```

# 幂等性
## 什么是接口的幂等性
用户的一个请求多次发送对于服务端的结果是一致的, 不会产生副作用

比如开发中, 一次或多次请求对资源的影响一致
- 同一用户对一个博客点赞, 无论点击几次, 只能 + 1 赞
- 对一个订单请求多次点击, 只能创建一个订单, 特别是对于分布式环境

## http 与幂等
### 查询 get
天生幂等, 因为对于服务器的资源没有改变, 即使两次查询的结果不一致, 也是幂等的
### 删除 delete
也是幂等的, 虽然删除了服务端的资源, 但是一般删除都是定向删除, 比如删除手机号为 8928 的记录, 后续请求已经没有该资源也不会对系统造成错误
### 修改 put
可能幂等, 也可能不幂等
比如将 id 为 5 的用户的手机号设置为 8928, 则为幂等的
又如将 id 为 5 的用户的金额 -100, 则为非幂等的
### 新增 post
非幂等的, 一般用于新增资源

## 实现幂等
1. 去重表
- 可以利用数据库的==唯一索引约束==
- 又或者在业务端构建 hashset
2. 状态标识
给某个资源打上状态标识, 比如订单可分为 1)订单初始化 2)订单支付 3)账户金额改变 4)通知商家. 
在完成一个流程后, 将订单状态转变, 一旦订单进入下一状态, 则来自上一个状态的请求则无效, 
比如订单已进入账户金额计算, 则请求支付则可以返回, 上述操作可能非原子, 需要加锁 
3. token 机制
在提交请求时携带唯一 token, 服务器根据该 token 来保证不会重复执行
比如: 在用户发帖进入编辑页面时, 生成 token, 点击发帖按钮将表单上传时, 同时上传 token.

# 给你两个球，100层楼，每个球在一定高度扔下去会碎，怎么用最少的次数给判断是几层楼能把求摔碎？
不能二分, 如果直接在 50 层碎了, 那么剩下一个鸡蛋只能线性从 1 开始

0. 可以设从 k 层扔下
1. 碎了, 最坏情况, 从 1 开始线性查找到 k-1 层都没碎, 得到总计 k 次
2. 没碎, 从 k+(k-1) 层扔下, 返回 0, 最终也是 k 次(第一个鸡蛋 k 层一次, 2k-1 层一次. 第二个鸡蛋 k+1 到 2k - 2).

从 k 层扔下一共可以探测出 k + k-1 + k-2 +...+ 1 **+ 1** 层, 因为最后那层不需要扔也能推断.

比如从 3 层开始, 假设第一个鸡蛋没碎, 楼层依次为 ``3, 5, 6``, 如果 6 层碎了, 那么结果就是第六层, 如果没碎, 那么由于一定会碎, 则肯定是第七层, 因此第二个鸡蛋不用扔下

公式为:
```math
k + k-1 +...+ 1 + 1 >= n
```

当 n 为 100, 解出 k = 14
第一个鸡蛋从 14, 27, 39, 50, 60, 69, 77, 84, 90, 95, 99 扔下, 中间某层碎了, 则第二个鸡蛋线性查找

[参考](https://www.bilibili.com/video/BV1KE41137PK)

# 3*3的九宫格，填写1—9，使得所有行、列、对角线的和都是相等的
1. 1+2+...+9 = 45
2. 而每一行相同, 则 45/3 = 15
3. 而中间的元素参与的次数最多, 第二行, 第二列, 两个对角线. 只有 5 能做到
1 + 9 + 5, 2 + 8 + 5, 3 + 7 + 5, 4 + 6 + 5
4. 确定中间为 5, 再确定 9, 只有 1 + 9 + 5 和 9 + 4 + 2 可以得到 15, 因此 9 必须在边而不能在角上
5. 得到 
```
4  9  2   
   5  
   1
```
6. 其他照着填就行

# 分布式一致性
## raft 协议
### raft 中节点有三种状态
1. Leader
2. Follower
3. Candidate

三种状态转换如下:
![](https://pic2.zhimg.com/80/v2-04ad92197a0c7e0cc304b50dfb32cad9_720w.png)


1. 当启动时, 所有节点都是 follower
2. 此时由于集群没有 leader, 因此会超时, 所有节点进入 candidate
3. 每个节点都会像所有节点请求投票给自己
4. candidate 将进入下列状态变迁
    1. 成为 leader, 当收到大多数节点(>(n/2)+1)投票时
    2. 成为 follower, 当收到比自己大的 term 的节点发来的请求投票时
    3. 发起新一轮选举, 以上都没有达到时, 同时自己的 term 会+1

### 选举
向其他节点发起投票请求时, 需要携带一定的参数

请求参数:
- term: 当前节点hold的任期
- candidateId: 节点id
- lastLogIndex: 最后日志条目索引值
- lastLogTerm: 最后日志条目的任期

返回响应:
- term: 被请求节点的任期
- voteGranted: 是否同意投票给候选人

发送时:
1. 自增当前节点的 term
2. 给自己投票
3. 重置选举超时计时器(超时会进入下一轮选举)
4. 发送

收到请求时(==注意只有 candidate 才能投票==):
1. 判断收到的 term 和自己的 term 的大小
    1. 如果比自己小, 则直接丢弃
    2. 如果比自己大, 则更新自己的 term, 并降级为 follower
2. 检测当前节点的投票状态
    1. 如果没有投过票, 或者已经给请求节点投票, 则到 3
    2. 否则, 拒绝投票 (设置 voteGranted = false), 因为一个节点在一个 term 只能投票一次
3. 检测请求者的日志是否比当前节点的新, 通过比较 lastLogIndex 和 lastLogTerm 实现
    1. 如果当前请求者的 term 与 当前节点相同, 且请求者的日志长度大于当前节点日志长度/请求者 term 大于当前节点 term, 则为其投票 (设置 voteGranted = true), 并成为 follower
    2. 否则拒绝投票

# 限流算法
## 计数限流
维护一个计数器, 设定阈值, 当进来一个请求时, 先判断此时的数量是否已经超过阈值, 如果超过, 则不允许服务, 否则, 将数量+1, 服务完成再减一

单机时, 需使用并发安全原子类
集群时, 可考虑 redis

缺点:
1. 不能顶住突发流量
2. 前面服务占用时间久, 即使是在等待 io, 也会使后面的服务堵住
3. 不能按照时间
## 固定窗口
相较计数限流多了时间窗口的概念, 比如限制一个小时只能对某一用户服务5次, 计时器每过一个时间窗口就重置次数

缺点:
1. 不能保证严格意义上的每一个小时. 比如在一个小时的最后1分钟把服务打满, 到第二个小时开始的第1分钟又把服务打满, 这样相当于在两分钟就服务了2n次

## 滑动窗口
维护当前时间到往前一个时间窗口的次数, 可以保证严格意义的一个时间窗口

具体实现 (redis):
1. 使用 zset, key 为 uid, member 为当前时间+随机数(防止member重复), score 也为当前时间
2. redis 提供删除 score 在某个范围的所有 member (zremRangeByScore)
3. 当请求服务时, 首先根据 uid 得到 zset, 再删除 score 的值为从 0 到当前时间往前一小时的所有 member
4. 此时剩下的所有 member 就是严格一个时间窗口的服务次数

缺点:
1. 不能应对突发的流量, 即不够平滑

## 漏桶算法
一般使用队列实现, 定时的流出, 比较像消息队列, 无论有多少突发的服务, 都是平滑的服务
![](https://segmentfault.com/img/remote/1460000023552197)

缺点:
1. 服务响应可能较慢

## 令牌桶算法
与漏桶相反, 令牌桶是定速的往桶里塞入令牌, 当服务到来时, 当取到令牌就能成功服务, 否则就拒绝

# 大数据量问题
[参考](https://blog.csdn.net/v_JULY_v/article/details/6279498)