# 奇怪的排序算法
[排序](https://zhuanlan.zhihu.com/p/53464092)

# bitmap

# rand5 实现 rand7
当实现比 randn 更小的数时, 可以直接丢弃大于 x 的值
```java
Rand5 rand5 = new Rand5();
public int rand3(Rand5 rand5) {
    int ret = Math.MAX_VALUE;
    while (ret > 3) {
        ret = rand5.nextInt();
    }
    return ret;
}
```

因此, 基于这样的思想, 我们可以构造一个大于目标数字的区间, 计算公式
```math
n * (randN - 1) + randN
```
如 rand5, rand5-1 = 0, 1, 2, 3, 4, 再乘 5, 则得到 0, 5, 10, 15, 20 的概率相等, 再加上 rand5, 则每个的概率为 1/5 * 1/5

```java
Rand5 rand5 = new Rand5();
public int rand7(Rand5 rand5) {
    int ret = Math.MAX_VALUE;
    // 能减少运行时间
    while (ret > 21) {
        ret = rand5.nextInt();
    }
    return ret % 7 + 1;
}
```

# 幂等性
## 什么是接口的幂等性
用户的一个请求多次发送对于服务端的结果是一致的, 不会产生副作用

比如开发中, 一次或多次请求对资源的影响一致
- 同一用户对一个博客点赞, 无论点击几次, 只能 + 1 赞
- 对一个订单请求多次点击, 只能创建一个订单, 特别是对于分布式环境

## http 与幂等
### 查询 get
天生幂等, 因为对于服务器的资源没有改变, 即使两次查询的结果不一致, 也是幂等的
### 删除 delete
也是幂等的, 虽然删除了服务端的资源, 但是一般删除都是定向删除, 比如删除手机号为 8928 的记录, 后续请求已经没有该资源也不会对系统造成错误
### 修改 put
可能幂等, 也可能不幂等
比如将 id 为 5 的用户的手机号设置为 8928, 则为幂等的
又如将 id 为 5 的用户的金额 -100, 则为非幂等的
### 新增 post
非幂等的, 一般用于新增资源

## 实现幂等
1. 去重表
- 可以利用数据库的==唯一索引约束==
- 又或者在业务端构建 hashset
2. 状态标识
给某个资源打上状态标识, 比如订单可分为 1)订单初始化 2)订单支付 3)账户金额改变 4)通知商家. 
在完成一个流程后, 将订单状态转变, 一旦订单进入下一状态, 则来自上一个状态的请求则无效, 
比如订单已进入账户金额计算, 则请求支付则可以返回, 上述操作可能非原子, 需要加锁 
3. token 机制
在提交请求时携带唯一 token, 服务器根据该 token 来保证不会重复执行
比如: 在用户发帖进入编辑页面时, 生成 token, 点击发帖按钮将表单上传时, 同时上传 token.

# 给你两个球，100层楼，每个球在一定高度扔下去会碎，怎么用最少的次数给判断是几层楼能把求摔碎？
不能二分, 如果直接在 50 层碎了, 那么剩下一个鸡蛋只能线性从 1 开始

0. 可以设从 k 层扔下
1. 碎了, 最坏情况, 从 1 开始线性查找到 k-1 层都没碎, 得到总计 k 次
2. 没碎, 从 k+(k-1) 层扔下, 返回 0, 最终也是 k 次(第一个鸡蛋 k 层一次, 2k-1 层一次. 第二个鸡蛋 k+1 到 2k - 2).

从 k 层扔下一共可以探测出 k + k-1 + k-2 +...+ 1 **+ 1** 层, 因为最后那层不需要扔也能推断.

比如从 3 层开始, 假设第一个鸡蛋没碎, 楼层依次为 ``3, 5, 6``, 如果 6 层碎了, 那么结果就是第六层, 如果没碎, 那么由于一定会碎, 则肯定是第七层, 因此第二个鸡蛋不用扔下

公式为:
```math
k + k-1 +...+ 1 + 1 >= n
```

当 n 为 100, 解出 k = 14
第一个鸡蛋从 14, 27, 39, 50, 60, 69, 77, 84, 90, 95, 99 扔下, 中间某层碎了, 则第二个鸡蛋线性查找

[参考](https://www.bilibili.com/video/BV1KE41137PK)

# 3*3的九宫格，填写1—9，使得所有行、列、对角线的和都是相等的
1. 1+2+...+9 = 45
2. 而每一行相同, 则 45/3 = 15
3. 而中间的元素参与的次数最多, 第二行, 第二列, 两个对角线. 只有 5 能做到
1 + 9 + 5, 2 + 8 + 5, 3 + 7 + 5, 4 + 6 + 5
4. 确定中间为 5, 再确定 9, 只有 1 + 9 + 5 和 9 + 4 + 2 可以得到 15, 因此 9 必须在边而不能在角上
5. 得到 
```
4  9  2   
   5  
   1
```
6. 其他照着填就行
