# 奇怪的排序算法
[排序](https://zhuanlan.zhihu.com/p/53464092)

# bitmap

# rand5 实现 rand7
当实现比 randn 更小的数时, 可以直接丢弃大于 x 的值
```java
Rand5 rand5 = new Rand5();
public int rand3(Rand5 rand5) {
    int ret = Math.MAX_VALUE;
    while (ret > 3) {
        ret = rand5.nextInt();
    }
    return ret;
}
```

因此, 基于这样的思想, 我们可以构造一个大于目标数字的区间, 计算公式
```math
n * (randN - 1) + randN
```
如 rand5, rand5-1 = 0, 1, 2, 3, 4, 再乘 5, 则得到 0, 5, 10, 15, 20 的概率相等, 再加上 rand5, 则每个的概率为 1/5 * 1/5

```java
Rand5 rand5 = new Rand5();
public int rand7(Rand5 rand5) {
    int ret = Math.MAX_VALUE;
    // 能减少运行时间
    while (ret > 21) {
        ret = rand5.nextInt();
    }
    return ret % 7 + 1;
}
```

# 幂等性
## 什么是接口的幂等性
用户的一个请求多次发送对于服务端的结果是一致的, 不会产生副作用

比如开发中, 一次或多次请求对资源的影响一致
- 同一用户对一个博客点赞, 无论点击几次, 只能 + 1 赞
- 对一个订单请求多次点击, 只能创建一个订单, 特别是对于分布式环境

## http 与幂等
### 查询 get
天生幂等, 因为对于服务器的资源没有改变, 即使两次查询的结果不一致, 也是幂等的
### 删除 delete
也是幂等的, 虽然删除了服务端的资源, 但是一般删除都是定向删除, 比如删除手机号为 8928 的记录, 后续请求已经没有该资源也不会对系统造成错误
### 修改 put
可能幂等, 也可能不幂等
比如将 id 为 5 的用户的手机号设置为 8928, 则为幂等的
又如将 id 为 5 的用户的金额 -100, 则为非幂等的
### 新增 post
非幂等的, 一般用于新增资源

## 实现幂等
1. 去重表
- 可以利用数据库的==唯一索引约束==
- 又或者在业务端构建 hashset
2. 状态标识
给某个资源打上状态标识, 比如订单可分为 1)订单初始化 2)订单支付 3)账户金额改变 4)通知商家. 
在完成一个流程后, 将订单状态转变, 一旦订单进入下一状态, 则来自上一个状态的请求则无效, 
比如订单已进入账户金额计算, 则请求支付则可以返回, 上述操作可能非原子, 需要加锁 
3. token 机制
在提交请求时携带唯一 token, 服务器根据该 token 来保证不会重复执行
比如: 在用户发帖进入编辑页面时, 生成 token, 点击发帖按钮将表单上传时, 同时上传 token.

# 给你两个球，100层楼，每个球在一定高度扔下去会碎，怎么用最少的次数给判断是几层楼能把求摔碎？
不能二分, 如果直接在 50 层碎了, 那么剩下一个鸡蛋只能线性从 1 开始

0. 可以设从 k 层扔下
1. 碎了, 最坏情况, 从 1 开始线性查找到 k-1 层都没碎, 得到总计 k 次
2. 没碎, 从 k+(k-1) 层扔下, 返回 0, 最终也是 k 次(第一个鸡蛋 k 层一次, 2k-1 层一次. 第二个鸡蛋 k+1 到 2k - 2).

从 k 层扔下一共可以探测出 k + k-1 + k-2 +...+ 1 **+ 1** 层, 因为最后那层不需要扔也能推断.

比如从 3 层开始, 假设第一个鸡蛋没碎, 楼层依次为 ``3, 5, 6``, 如果 6 层碎了, 那么结果就是第六层, 如果没碎, 那么由于一定会碎, 则肯定是第七层, 因此第二个鸡蛋不用扔下

公式为:
```math
k + k-1 +...+ 1 + 1 >= n
```

当 n 为 100, 解出 k = 14
第一个鸡蛋从 14, 27, 39, 50, 60, 69, 77, 84, 90, 95, 99 扔下, 中间某层碎了, 则第二个鸡蛋线性查找

[参考](https://www.bilibili.com/video/BV1KE41137PK)

# 3*3的九宫格，填写1—9，使得所有行、列、对角线的和都是相等的
1. 1+2+...+9 = 45
2. 而每一行相同, 则 45/3 = 15
3. 而中间的元素参与的次数最多, 第二行, 第二列, 两个对角线. 只有 5 能做到
1 + 9 + 5, 2 + 8 + 5, 3 + 7 + 5, 4 + 6 + 5
4. 确定中间为 5, 再确定 9, 只有 1 + 9 + 5 和 9 + 4 + 2 可以得到 15, 因此 9 必须在边而不能在角上
5. 得到 
```
4  9  2   
   5  
   1
```
6. 其他照着填就行

# 分布式一致性
## raft 协议
### raft 中节点有三种状态
1. Leader
2. Follower
3. Candidate

三种状态转换如下:
![](https://pic2.zhimg.com/80/v2-04ad92197a0c7e0cc304b50dfb32cad9_720w.png)


1. 当启动时, 所有节点都是 follower
2. 此时由于集群没有 leader, 因此会超时, 所有节点进入 candidate
3. 每个节点都会像所有节点请求投票给自己
4. candidate 将进入下列状态变迁
    1. 成为 leader, 当收到大多数节点(>(n/2)+1)投票时
    2. 成为 follower, 当收到比自己大的 term 的节点发来的请求投票时
    3. 发起新一轮选举, 以上都没有达到时, 同时自己的 term 会+1

### 选举
向其他节点发起投票请求时, 需要携带一定的参数

请求参数:
- term: 当前节点hold的任期
- candidateId: 节点id
- lastLogIndex: 最后日志条目索引值
- lastLogTerm: 最后日志条目的任期

返回响应:
- term: 被请求节点的任期
- voteGranted: 是否同意投票给候选人

发送时:
1. 自增当前节点的 term
2. 给自己投票
3. 重置选举超时计时器(超时会进入下一轮选举)
4. 发送

收到请求时(==注意只有 candidate 才能投票==):
1. 判断收到的 term 和自己的 term 的大小
    1. 如果比自己小, 则直接丢弃
    2. 如果比自己大, 则更新自己的 term, 并降级为 follower
2. 检测当前节点的投票状态
    1. 如果没有投过票, 或者已经给请求节点投票, 则到 3
    2. 否则, 拒绝投票 (设置 voteGranted = false), 因为一个节点在一个 term 只能投票一次
3. 检测请求者的日志是否比当前节点的新, 通过比较 lastLogIndex 和 lastLogTerm 实现
    1. 如果当前请求者的 term 与 当前节点相同, 且请求者的日志长度大于当前节点日志长度/请求者 term 大于当前节点 term, 则为其投票 (设置 voteGranted = true), 并成为 follower
    2. 否则拒绝投票

# 大数据量问题
[参考](https://blog.csdn.net/v_JULY_v/article/details/6279498)

## bitmap
适合于知道范围的数据, 计算 max-min 得到需要多少位

## 前缀树
适合于字符串, 且前缀比较雷同, 如 url

## 堆排序
常用

## 快排
常用

## hash
常用于数据量过大, 找高频的字符串
将字符串的hash值取余, 到各个小文件, 可以保证相同的字符串保存到相同的小文件

# 分页缓存的设计
缓存设计的三个要点：
1. 初始化
2. 更新
3. 清除

## 使用 redis
### 排序与数据分开
1. 分成两部分
    1. 使用zset, member 为 id(主键), score 为 order by 的键
    2. string, key 为 id(主键), value 为序列化后的对象
    ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e3b9678058446e49ba9d79f5d406089~tplv-k3u1fbpfcp-watermark.image)
2. 查询时, 需要获取所需页的所有 id
3. 根据 id 查询对应对象, 如果不在 redis, 则根据 id 去数据库查询后, 更新缓存

1. 初始化
将所有 id 放入 zset, 热点对象可以预先序列化后放进 string
2. 更新
数据新增/删除/对应的 排序列更新时, 更新 id
数据更新时删除对象
3. 删除
仅当 id 删除时
对象可设置缓存时间