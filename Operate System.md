# 用户态与核心态
![](https://pic3.zhimg.com/80/v2-c9263b0dfebc2a68731cd198081fee46_720w.png)

因为不同指令之间存在权限差异，CPU分为了用户态和内核态，内核态用来运行特权指令和内核程序。所以对应的操作系统分成非内核功能和内核功能，其中内核是操作系统最主要最核心的部分

# 三种上下文切换
进程上下文切换

一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）

线程上下文切换

前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。前后两个线程属于同一个进程。只需要切换线程的私有数据、寄存器等不共享的数据

中断上下文切换

中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。收到信号处理时触发

# BIO\NIO\同步IO\异步IO
IO操作分2个步骤，请求IO和实际IO
**请求 IO :** 进程向内核发出 IO 请求, 内核返回数据报文是否已准备好
**实际 IO :** 从内核向进程复制数据

**举例 :** 对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区
> 用户空间和内核空间
    1. 操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立（一个进程的崩溃不会影响其他的进程 ， 恶意进程不能直接读取和修改其他进程运行时的代码和数据）。 因此操作系统内核需要拥有高于普通进程的权限， 以此来调度和管理用户的应用程序。
    2. 于是内存空间被划分为两部分，一部分为内核空间，一部分为用户空间，内核空间存储的代码和数据具有更高级别的权限。内存访问的相关硬件在程序执行期间会进行访问控制（ Access Control），使得用户空间的程序不能直接读写内核空间的内存

==阻塞, 非阻塞是针对第一阶段而言
同步, 非同步是针对第二阶段而言==

![](https://static.oschina.net/uploads/img/201604/21095604_vhHX.png)

**1. 阻塞IO**
![](https://pic2.zhimg.com/80/e83d68da03da2e8c1568b4b4b630edfd_1440w.jpg?source=1940ef5c)

**2. 非阻塞IO**
![](https://pic1.zhimg.com/80/4bc31cab27a9a732ab7d1ba9e674ed64_1440w.jpg?source=1940ef5c)
进程把一个套接字设置成非阻塞是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。==recvfrom总是立即返回==

**3. IO 多路复用**
![](https://pic2.zhimg.com/80/b1ec6a4f16844a27c175d5a6a94cd7f8_1440w.jpg?source=1940ef5c)
I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。

**4. 异步 IO**
![](https://pic1.zhimg.com/80/5819fd0fdff2bd4fdc9652291aca1831_1440w.jpg?source=1940ef5c)
工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们

## 阻塞原理
阻塞是指进程在发起了一个系统调用（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源

> 系统调用（system call）
    system call 是操作系统提供给应用程序的接口。 用户通过调用 systemcall 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等。

**工作队列:**
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221075-ac2ec9f0-c364-40a9-a8d6-ec7abae56599.jpeg)
操作系统为了支持多任务, 把进程分为 "运行" 和 "等待" 等几种状态
如上图的进程 A, 在执行到 recv 整个 IO 阻塞方法时, 操作系统会将其转换为 "等待" 状态, 等到接收到数据, 再转换为 "运行" 的状态

**等待队列**
当进程 A 执行创建 socket 的语句时, 操作系统会创建一个由文件系统(图中的文件列表)管理的 socket 对象
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221524-91520e15-e756-4a79-988c-cf8be8068f90.jpeg)
一个 socket 对象包括收发缓冲区, 和等待列表, 当进程 A 执行到 recv 方法的时候, 会把该进程放入对应的 socket 对象的等待队列中(==对于阻塞 IO 来说==)
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221078-f8a161c0-5ca2-47dc-ba2b-c044e41c7de1.jpeg)


## IO 多路复用
### select
select 的伪代码
```c
int s = socket(AF_INET, SOCK_STREAM, 0); 
bind(s, ...) 
listen(s, ...) 
int fds[] = 存放需要监听的socket 
while (1) { 
    int n = select(..., fds, ...) 
    for(int i=0; i < fds.count; i++){ 
        if(FD_ISSET(fds[i], ...)){ 
            //fds[i]的数据处理 
        } 
    } 
}
```
#### select 的流程
1. 当进程 A 需要监听多个 socket 的时候, 便把该进程加入到需要监听的 socket 的等待队列里
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221394-15a15def-7d6a-40b9-9389-64dff4a0c68a.jpeg)
2. 当其中一个 socket 接收到数据, 操作系统将唤醒在该 socket 的等待队列中的线程 A
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221471-7df6eef9-f66e-4729-8f1a-773e465492c9.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_eXVsb25nc3Vu%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)
3. 线程A 被唤醒后, 由于不知道是哪个 socket 接收到数据, 因此需要遍历一遍 socket 列表, 即伪代码里的 fds

**缺点:**
1. 每次唤醒后, 需要遍历一遍 socket 列表来确认哪个 socket 对象接收到数据(因此, 规定最大只能监控 1024 个 socket 对象)
2. 每次执行完, 需要重新将进程A 加入到各个 socket 对象的等待队列中

#### epoll
```c
int s = socket(AF_INET, SOCK_STREAM, 0); 
bind(s, ...) 
listen(s, ...) 
int epfd = epoll_create(...); 
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中 
while(1) { 
    int n = epoll_wait(...) 
    for(接收到数据的socket){ 
        //处理 
    } 
}
```
#### epoll 流程
1. 创建 epoll 对象, 当进程A 执行 epoll_creat 方法时, 内核会创建一个 eventpoll 对象(伪代码里的 epfd)
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221115-cdca633e-0069-4b49-aac7-884c5e279f25.jpeg)
eventpoll 对象也是文件系统的一员
2. 维护监视列表
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221111-214398cf-4adc-479b-aeeb-2351cfc315a6.jpeg)
==内核会将 eventpoll 添加到进程 A 需要监听的 Socket 的等待队列中==
当 Socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程
3. 接收数据
当 socket 接收到数据之后, 中断程序会给 eventpoll 对象中的就序列表(rdlist) 添加 socket 引用
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221169-416a5e91-600c-47f2-b004-0f6a2c192e71.jpeg)
4. 阻塞和唤醒进程
当进程 A 运行到 epoll_wait() 方法时, 操作系统会把进程A 放在 eventpoll 对象的等待队列里, 然后阻塞进程 A
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221241-a82b67e8-8b22-4b1a-aaea-da9f5b333596.jpeg)
当 socket 接收到数据, 中断程序一方面将 socket 放入 rdlist, 另一方面将 eventpoll 中的进程 A 唤醒进入运行状态
![](https://cdn.nlark.com/yuque/0/2020/jpeg/181910/1608369221108-acb69d23-01d1-4a50-a177-84193b28effd.jpeg?)

##### epoll水平和边缘触发的区别?
在进程执行 epoll_wait() 操作时, 水平触发和边缘触发对进程唤醒从策略不同
1. 边缘触发 (edge trigger)
    **读操作**
    1. 在 buffer 由不可读变为可读的时候  
    ![](http://blog.chinaunix.net/attachment/201406/3/28541347_14018059421VJj.png)
    2. 在 buffer 有新数据到达时
    ![](http://blog.chinaunix.net/attachment/201406/3/28541347_14018059521U1k.png)

    **写操作**
    1. 在 buffer 由不可写变为可写的时候
    2. 当有旧数据被发送走时，即buffer中待写的内容变少得时候
    ![](http://blog.chinaunix.net/attachment/201406/3/28541347_1401805980jh7p.png)

2. 水平触发 (level trigger)
    LT模式下进程被唤醒（描述符就绪）的条件就简单多了，它包含==ET模式的所有条件==。此外，还有更普通的情况LT可以被唤醒，而ET则不理会，这也是我们需要注意的情况。

    **读操作**
    当buffer中有数据，且数据被读出一部分后buffer还不空的时候，即buffer中的内容减少的时候，LT模式返回读就绪。==只要还可读, 就返回读就绪==
    ![](http://blog.chinaunix.net/attachment/201406/3/28541347_14018060158h95.png)
    **写操作**
    当buffer不满，又写了一部分数据后扔然不满的的时候，即由于写操作的速度大于发送速度造成buffer中的内容增多的时候，LT模式会返回就绪
    ![](http://blog.chinaunix.net/attachment/201406/3/28541347_1401806029se68.png)

# 文件描述符
一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为**文件描述符**（File Descriptor）
一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着==当前进程所有可用的文件描述符==，也即当前进程所有打开的文件。

除了文件描述符表，系统还需要维护另外两张表：
- 打开文件表（Open file table）
- i-node 表（i-node table）

==文件描述符表每个进程都有一个，打开文件表和 i-node 表整个系统只有一个==

![](http://c.biancheng.net/uploads/allimg/190410/1-1Z4101H45S13.gif)

通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：
- 文件偏移量，也就是文件内部指针偏移量。调用 read() 或者 write() 函数时，文件偏移量会自动更新，当然也可以使用 lseek() 直接修改。
- 状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。
- i-node 表指针。

然而，要想真正读写文件，还得通过打开文件表的 i-node 指针进入 i-node 表，该表包含了诸如以下的信息：
- 文件类型，例如常规文件、套接字或 FIFO。
- 文件大小。
- 时间戳，比如创建时间、更新时间。
- 文件锁

- 在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。
- 进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。
- 进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况

# 进程/线程/协程
**进程是资源分配的最小单位，线程是CPU调度的最小单位**

没有进程的操作系统只能运行单个程序，对于多个程序在内存分配的位置和大小都需要管理，所以进程是系统资源的分配单位。尤其引入线程之后，进程作为除了CPU之外系统资源的分配单元（如打印机，内存空间）。线程只占了CPU，剩下还是以进程为单位划分

引入进程可以使各个程序之间并发执行，但是对于一个程序内部来说所有的功能如果都限制为顺序执行显然对用户体验不好。为此我们引入线程的概念，来增加进程内部的并发度，比如我们用QQ发送文件的时候还可以聊天

![](https://pic4.zhimg.com/80/v2-c9b5a1f7585d8873b640b7391c51b443_720w.jpg)

**协程**
在用户态实现, 一种轻量级的线程
线程的弊端, 在执行比如 IO 操作时, 会阻塞等待返回. 此时协程可以主动让出, 而协程的切换不需要像线程一样依赖于操作系统, 从用户态到内核态的转换, 

# 进程间通信
[参考: ipc](https://www.jianshu.com/p/c1015f5ffa74)
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信**（IPC，InterProcess Communication）

![](https://upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png)

1. **匿名管道**
    比如 `ls | grep hello`
    - 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
    - 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程). ==因为父子进程共享内存空间, 因此可以访问==
    - 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它==不属于某种文件系统==，而是自立门户，单独构成一种文件系统，并且==只存在与内存==中。
    - 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据

    **管道的实质**
    - 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
    - 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
    - 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写

    **管道的缺点**
    - 只支持单向数据流；
    - 只能用于具有亲缘关系的进程之间；
    - 没有名字(文件描述符, 即非亲属线程不能访问数组下标)；
    - 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
    - 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等

2. **有名管道**
    有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，==以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信==，因此，通过有名管道不相关的进程也能交换数据. ==有名管道的名字存在于文件系统中，内容存放在内存中==。

>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

3. **信号**
    - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
    - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
    - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程

    > Linux系统中常用信号：
    （1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
    （2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。
    （3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。
    （4）SIGBUS和SIGSEGV：进程访问非法地址。
    （5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。
    （6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。
    （7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。
    （8）SIGALRM：定时器信号。
    （9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

    **信号来源:**
    信号是==软件层次上对中断机制的一种模拟，是一种异步通信方式==，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源
    - 硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。
    - 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号

    **信号生命周期和流程**
    （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
    （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
    （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。

    ![](https://upload-images.jianshu.io/upload_images/1281379-3eed8cca67aa9f55.png)

4. 消息队列

5. **共享内存**
- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
- 由于多个进程共享一段内存，因此需要依靠某种==同步机制, 如信号量==来达到进程间的同步及互斥。

![](https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png)

6. **信号量**
    信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
    为了获得共享资源，进程需要执行下列操作：
    1. 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
    2. 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
    3. 挂出一个信号量：该操作将信号量的值加1，也称为V操作。

    为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在==内核中==实现的。Linux环境中，有三种类型

    ![](https://upload-images.jianshu.io/upload_images/1281379-a72c8fbe22340031.png)

    > **信号量与互斥量**
    （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别
    互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
    同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
    在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
    （2）互斥量值只能为0/1，信号量值可以为非负整数。
    也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。
    （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。


## 线程通信
1. 加锁(synchronized, ReentrantLock, 乐观锁)
2. wait, notify 机制
3. 信号量 (Semaphore)